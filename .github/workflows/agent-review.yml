name: Agent Review

on:
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review]
  issues:
    types: [opened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  classify:
    runs-on: ubuntu-latest
    outputs:
      category: ${{ steps.classify.outputs.category }}
    steps:
      - name: Classify contribution
        id: classify
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = !!context.payload.pull_request;
            const title = isPR
              ? context.payload.pull_request.title
              : context.payload.issue.title;
            const body = isPR
              ? context.payload.pull_request.body || ''
              : context.payload.issue.body || '';
            const text = `${title}\n${body}`.toLowerCase();

            // aesthetic/UI keywords
            const aestheticPatterns = [
              'redesign', 'restyle', 'theme', 'color', 'colour', 'font',
              'layout', 'css', 'styling', 'ui overhaul', 'visual',
              'dark mode', 'light mode', 'icon', 'logo', 'animation',
              'prettier', 'beautif'
            ];

            const isAesthetic = aestheticPatterns.some(p => text.includes(p));
            const isBugFix = text.includes('fix') || text.includes('bug') ||
              text.includes('crash') || text.includes('error') ||
              text.includes('broken') || text.includes('regression');

            let category = 'feature';
            if (isAesthetic) category = 'aesthetic';
            if (isBugFix) category = 'bugfix';

            core.setOutput('category', category);
            console.log(`Classified as: ${category}`);

  review-pr:
    if: github.event_name == 'pull_request_target'
    needs: classify
    runs-on: ubuntu-latest
    outputs:
      verdict: ${{ steps.extract-verdict.outputs.verdict }}
      decision: ${{ steps.extract-verdict.outputs.decision }}
      decision_comment_url: ${{ steps.extract-verdict.outputs.decision_comment_url }}
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Read project scope
        id: scope
        run: |
          if [ -f SCOPE.md ]; then
            echo "scope<<SCOPE_EOF" >> $GITHUB_OUTPUT
            cat SCOPE.md >> $GITHUB_OUTPUT
            echo "SCOPE_EOF" >> $GITHUB_OUTPUT
          fi

      - name: Agent Review
        id: claude-review
        continue-on-error: false
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          allowed_non_write_users: "*"
          claude_args: |
            --model claude-opus-4-6
            --json-schema '{"type":"object","properties":{"classification":{"type":"string"},"scope_verdict":{"type":"string"},"code_quality":{"type":"string"},"security":{"type":"string"},"tests":{"type":"string"},"decision":{"type":"string","enum":["APPROVE","REQUEST CHANGES","CLOSE"]},"summary":{"type":"string"},"review_comment":{"type":"string"}},"required":["decision","review_comment"]}'
          prompt: |
            Reference the following project scope document when making review decisions:
            ${{ steps.scope.outputs.scope }}

            You are the sole code reviewer for the Milaidy project. This is an agents-only codebase. No human contributions are accepted — humans contribute by using the app and reporting bugs as QA testers. Your review is final.

            PRs are expected to follow the structured PR template with clear sections for what, why, how, and testing. Flag missing or weak sections.

            ## Classification
            This PR has been pre-classified as: ${{ needs.classify.outputs.category }}

            ## Review Protocol

            ### 1. Scope Check
            Milaidy is a personal AI assistant built on ElizaOS. Contributions MUST be in scope:

            **IN SCOPE (welcome):**
            - Bug fixes (connector issues, crashes, regressions, error handling)
            - Performance improvements (with benchmarks proving improvement)
            - Security fixes
            - Test coverage improvements
            - Documentation fixes for accuracy

            **REQUIRES DEEP REVIEW (may not get merged):**
            - New features (must align with project mission, must include tests)
            - New plugins or integrations
            - Architectural changes
            - Memory/context improvements (must include benchmarks)
            - Dependency additions (must justify why)

            **OUT OF SCOPE (close or request changes):**
            - Frontend redesigns, aesthetic changes, theme changes, icon swaps
            - "Beautification" PRs that don't improve agent capability
            - Changes that prioritize human visual experience over agent quality
            - Scope creep disguised as improvements
            - Changes without tests for testable code

            If this PR is classified as "aesthetic": reject it firmly but politely. Explain that this project prioritizes agent capability over human-facing aesthetics. Visual changes that don't improve the agent's function are out of scope.

            ### 2. Code Quality
            - TypeScript strict mode compliance
            - No `any` types unless absolutely necessary (explain why)
            - Biome lint/format compliance
            - Files under ~500 LOC
            - Meaningful variable names, brief comments on non-obvious logic
            - No committed secrets, real phone numbers, or live config values
            - Dependencies: do NOT add unless src/ code directly imports them

            ### 3. Security Review
            - Check for prompt injection vectors
            - Check for credential exposure
            - Check for supply chain risks (new dependencies, postinstall scripts)
            - Check for data exfiltration patterns
            - Flag any changes to auth, permissions, or secret handling

            ### 4. Test Requirements
            - Bug fixes MUST include a regression test
            - New features MUST include unit tests
            - Coverage thresholds: 70% lines/branches/functions/statements
            - Run `bun run test` mentally — would these tests pass?

            ### 5. Dark Forest Awareness
            Assume adversarial intent until proven otherwise. Ask yourself:
            - Why would someone submit this change?
            - What does it break that isn't obvious?
            - Does it introduce subtle behavior changes?
            - Could this be a supply chain attack?
            - Are there hidden side effects in seemingly innocent changes?

            ## Output Requirements
            Return JSON matching the provided schema.
            Put the full PR review markdown in `review_comment` with this exact structure:
            1. **Classification:** bug fix / feature / aesthetic / security / other
            2. **Scope verdict:** in scope / needs deep review / out of scope
            3. **Code quality:** pass / issues found (list them)
            4. **Security:** clear / concerns (list them)
            5. **Tests:** adequate / missing (specify what's needed)
            6. **Decision:** APPROVE / REQUEST CHANGES / CLOSE (with reason)

            Be direct. Be opinionated. This repo's quality is your responsibility.

      - name: Post structured review comment
        id: post-review-comment
        if: always() && steps.claude-review.outcome == 'success'
        uses: actions/github-script@v7
        env:
          STRUCTURED_OUTPUT: ${{ steps.claude-review.outputs.structured_output }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.pull_request.number;
            const marker = '<!-- agent-review:claude-structured -->';

            let parsed = {};
            const raw = process.env.STRUCTURED_OUTPUT || '';

            if (raw) {
              try {
                parsed = JSON.parse(raw);
              } catch (error) {
                core.warning(`Failed to parse structured_output: ${error}`);
              }
            } else {
              core.warning('Claude action did not return structured_output.');
            }

            const decision = String(parsed.decision || 'REQUEST CHANGES').toUpperCase();
            let reviewBody = String(parsed.review_comment || '').trim();

            if (!reviewBody) {
              reviewBody = [
                '**Classification:** other',
                '**Scope verdict:** needs deep review',
                '**Code quality:** issues found (missing structured output)',
                '**Security:** concerns (missing structured output)',
                '**Tests:** missing (missing structured output)',
                `**Decision:** ${decision} (Claude output did not include review_comment)`
              ].map((line, idx) => `${idx + 1}. ${line}`).join('\n');
            }

            if (!/(?:^|\n)\s*(?:\d+\.\s*)?\*\*?Decision:/i.test(reviewBody)) {
              reviewBody += `\n\n6. **Decision:** ${decision}`;
            }

            const body = `${marker}\n${reviewBody}`;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100,
            });

            const existing = [...comments]
              .reverse()
              .find((comment) => comment?.body?.includes(marker));

            let result;
            if (existing) {
              result = await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body,
              });
              console.log(`Updated existing review comment: ${existing.id}`);
            } else {
              result = await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body,
              });
              console.log(`Created new review comment: ${result.data.id}`);
            }

            core.setOutput('decision', decision);
            core.setOutput('comment_url', result.data.html_url || '');

      - name: Extract Claude decision
        id: extract-verdict
        if: always()
        uses: actions/github-script@v7
        env:
          POSTED_DECISION: ${{ steps.post-review-comment.outputs.decision }}
          DECISION_COMMENT_URL: ${{ steps.post-review-comment.outputs.comment_url }}
        with:
          script: |
            const normalized = String(process.env.POSTED_DECISION || 'REQUEST CHANGES').toUpperCase();
            const decision = ['APPROVE', 'REQUEST CHANGES', 'CLOSE'].includes(normalized)
              ? normalized
              : 'REQUEST CHANGES';

            let verdict = 'reject';
            if (decision === 'APPROVE') {
              verdict = 'approve';
            } else if (decision === 'CLOSE') {
              verdict = 'close';
            }

            const decisionCommentUrl = process.env.DECISION_COMMENT_URL || '';

            core.setOutput('verdict', verdict);
            core.setOutput('decision', decision);
            core.setOutput('decision_comment_url', decisionCommentUrl);

            core.summary
              .addHeading('Agent review decision gate')
              .addRaw(`- Verdict: ${verdict}\n`)
              .addRaw(`- Decision: ${decision}\n`)
              .addRaw(`- Decision comment: ${decisionCommentUrl || 'not found'}\n`)
              .write();

            console.log(`Verdict derived from structured output: ${verdict} (${decision})`);

  auto-merge:
    name: Auto-merge approved PRs
    needs: [classify, review-pr]
    if: github.event_name == 'pull_request_target' && needs.review-pr.result == 'success' && needs.review-pr.outputs.verdict == 'approve'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Enable auto-merge
        run: |
          method="${MERGE_METHOD:-squash}"
          case "$method" in
            merge|squash|rebase) ;;
            *)
              echo "Invalid AGENT_REVIEW_MERGE_METHOD='$method', defaulting to 'squash'"
              method="squash"
              ;;
          esac

          echo "Enabling auto-merge using '$method' method"
          gh pr merge ${{ github.event.pull_request.number }} --auto --"$method"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          MERGE_METHOD: ${{ vars.AGENT_REVIEW_MERGE_METHOD }}

  close-pr:
    name: Close PRs with CLOSE verdict
    needs: [review-pr]
    if: github.event_name == 'pull_request_target' && needs.review-pr.result == 'success' && needs.review-pr.outputs.verdict == 'close'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    steps:
      - name: Close PR after agent verdict
        run: |
          comment="Closing this pull request because the automated agent review decision was **CLOSE**."
          if [ -n "${DECISION_COMMENT_URL}" ]; then
            comment="$comment\n\nDecision source: ${DECISION_COMMENT_URL}"
          fi

          gh pr close ${{ github.event.pull_request.number }} --comment "$comment"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          DECISION_COMMENT_URL: ${{ needs.review-pr.outputs.decision_comment_url }}

  triage-issue:
    if: github.event_name == 'issues'
    needs: classify
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Triage Issue
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_args: '--model claude-opus-4-6'
          prompt: |
            You are the issue triager for the Milaidy project. This is an agents-only codebase where humans serve as QA testers.

            ## Classification
            This issue has been pre-classified as: ${{ needs.classify.outputs.category }}

            ## Triage Protocol

            **Valid issues (label and keep open):**
            - Bug reports with reproduction steps
            - Security vulnerabilities
            - Performance regressions with evidence
            - Connector/integration failures
            - Documentation inaccuracies

            **Needs more info (ask and label):**
            - Bug reports without reproduction steps
            - Vague descriptions ("it doesn't work")
            - Environment-specific issues without system details

            **Close immediately:**
            - Feature requests for aesthetic/UI changes
            - "Please redesign X" requests
            - Issues that are actually feature requests disguised as bugs
            - Duplicate issues (reference the original)
            - Issues clearly out of project scope

            **Respond with:**
            1. Thank the reporter (they're QA testers, their role matters)
            2. Classification and labels to apply
            3. If valid: acknowledge and note priority
            4. If closing: explain why clearly, reference scope
            5. If needs info: ask specific questions

            Remember: humans are QA testers here. Their bug reports are valuable. Their feature requests for visual changes are not. Be respectful but firm about scope.
